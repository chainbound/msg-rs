<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The MSG-RS Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The MSG-RS Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="msg-rs"><a class="header" href="#msg-rs">MSG-RS</a></h1>
<p><a href="https://github.com/chainbound/msg-rs"><img src="https://img.shields.io/badge/GitHub%20Repo-msg-green?logo=github"></a>
<a href="https://discord.gg/nhWcSWYpm9"><img src="https://img.shields.io/badge/Discord-x?logo=discord&label=chainbound"></a></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<blockquote>
<p>üìñ <a href="https://github.com/chainbound/msg-rs">MSG-RS</a> is a flexible and lightweight messaging library for distributed
systems built with Rust and Tokio, designed for performance and reliability.</p>
</blockquote>
<p>This library is built and maintained by <a href="https://chainbound.io/">Chainbound</a>, and is licensed
under the <a href="https://github.com/chainbound/msg-rs/blob/main/LICENSE">MIT License</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>MSG-RS is inspired by projects like <a href="https://zeromq.org/">ZeroMQ</a> and <a href="https://nanomsg.org/">Nanomsg</a>.
It was built because at Chainbound we needed a Rust-native messaging library
that was flexible and customizable enough without relying on C bindings or
external dependencies.</p>
<p>Another reason for building this library was to modularize the messaging
components of our <a href="https://fiber.chainbound.io/">Fiber</a> project. Lastly, this was also used as
an opportunity to dive deeper into some async rust patterns to measure
optimizations in isolation from other distributed system components.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p><strong>1. Flexible and modular</strong></p>
<p>MSG-RS is designed to be modular by leveraging Rust's traits and generics. This
modularity can be seen in all aspects, from the transport layer to the socket patterns.</p>
<p><strong>2. Durable</strong></p>
<p>Durability is a critical aspect in distributed systems. By using smart abstractions
like the ones from <a href="https://github.com/craftytrickster/stubborn-io">StubbornIO</a>, MSG is able to provide reliable
reconnections and retries out of the box.</p>
<p><strong>3. Extensible</strong></p>
<p>Even though MSG comes with different socket patterns and transport layers, it is also
designed to be easily extensible if you want to bring your own options like
authentication, encryption, and compression to the table.</p>
<h2 id="development-status"><a class="header" href="#development-status">Development Status</a></h2>
<p><strong>MSG is currently in ALPHA, and is not yet recommended for use in production.</strong></p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Contributors are welcome! Please see the <a href="https://github.com/chainbound/msg-rs/tree/main/CONTRIBUTING.md">contributing guide</a> for
more information.</p>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>This section will guide you through the process of adding MSG-RS to your project and
using it to build networked distributed systems.</p>
<ul>
<li><a href="usage/./getting-started.html">Getting started</a></li>
<li><a href="usage/./transport-layers.html">Transport Layers</a></li>
<li><a href="usage/./socket-types.html">Socket Types</a></li>
<li><a href="usage/./authentication.html">Connection Authentication</a></li>
<li><a href="usage/./compression.html">Message Compression</a></li>
<li><a href="usage/./encryption.html">Encryption</a></li>
<li><a href="usage/./logging.html">Logging</a></li>
<li><a href="usage/./faq.html">FAQ</a></li>
</ul>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-msg-rs"><a class="header" href="#getting-started-with-msg-rs">Getting started with MSG-RS</a></h1>
<p>To add MSG-RS to your project, add the following to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
msg = { git = "https://github.com/chainbound/msg-rs" }
</code></pre>
<p><strong>Warning: MSG-RS is currently in ALPHA, and is not yet recommended for use in production.</strong></p>
<p>We plan to release MSG-RS to <a href="https://crates.io/">Crates.io</a> once it reaches a beta stage.
Until then, we recommend using the git dependency as shown above.</p>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket-types"><a class="header" href="#socket-types">Socket types</a></h1>
<p>MSG-RS supports the following socket types:</p>
<ul>
<li><a href="usage/socket-types.html#requestreply">Request/Reply</a></li>
<li><a href="usage/socket-types.html#publishsubscribe">Publish/Subscribe</a></li>
</ul>
<!--
- [Push/Pull](#pushpull)
- [Channel](#channel)
- [Survey/Respond](#surveyrespond)
  -->
<h2 id="requestreply"><a class="header" href="#requestreply">Request/Reply</a></h2>
<p>The request/reply socket type is used for sending a request to a server and receiving a response.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">use bytes::Bytes;
use tokio_stream::StreamExt;

use msg::{RepSocket, ReqSocket, tcp::Tcp};

#[tokio::main]
async fn main() {
    // Initialize the reply socket (server side) with a transport
    let mut rep = RepSocket::new(Tcp::default());
    rep.bind("0.0.0.0:4444").await.unwrap();

    // Initialize the request socket (client side) with a transport
    let mut req = ReqSocket::new(Tcp::default());
    req.connect("0.0.0.0:4444").await.unwrap();

    tokio::spawn(async move {
        // Receive the request and respond with "world"
        // (RepSocket implements `Stream`)
        let req = rep.next().await.unwrap();
        println!("Message: {:?}", req.msg());

        req.respond(Bytes::from("world")).unwrap();
    });

    let res: Bytes = req.request(Bytes::from("hello")).await.unwrap();
    println!("Response: {:?}", res);
}</code></pre></pre>
<h2 id="publishsubscribe"><a class="header" href="#publishsubscribe">Publish/Subscribe</a></h2>
<p>The publish/subscribe socket type is used for sending a message to multiple subscribers.
It works by defining topics over which messages can be sent and received. Subscribers can
subscribe to one or more topics, and will receive all messages sent to those topics by
publishers.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">use bytes::Bytes;
use tokio_stream::StreamExt;

use msg::{PubSocket, SubSocket, tcp::Tcp};

#[tokio::main]
async fn main() {
    // Initialize the publisher socket (server side) with a transport
    let mut pub_socket = PubSocket::new(Tcp::default());
    pub_socket.bind("0.0.0.0:4444").await.unwrap();

    // Initialize the subscriber socket (client side) with a transport
    let mut sub_socket = SubSocket::new(Tcp::default());
    sub_socket.connect("0.0.0.0:4444").await.unwrap();

    let topic = "some_interesting_topic".to_string();

    // Subscribe to a topic
    sub_socket.subscribe(topic.clone()).await.unwrap();

    tokio::spawn(async move {
        // Values are `bytes::Bytes`
        pub_socket.publish(topic, Bytes::from("hello_world")).await.unwrap();
    });

    let msg = sub_socket.next().await.unwrap();
    println!("Received message: {:?}", msg);
}</code></pre></pre>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="transport-layers"><a class="header" href="#transport-layers">Transport layers</a></h1>
<p>MSG-RS supports multiple transport layers. The transport layer is the one that
handles the actual sending and receiving of messages. The following transport
layers are supported:</p>
<ul>
<li><a href="usage/transport-layers.html#tcp">TCP</a></li>
<li><a href="usage/transport-layers.html#quic">QUIC</a></li>
<li><a href="usage/transport-layers.html#ipc">IPC</a></li>
</ul>
<!--
- [Inproc](#inproc)
- [UDP](#udp)
- [TLS](#tls)
  -->
<h2 id="tcp"><a class="header" href="#tcp">TCP</a></h2>
<h3 id="why-choose-tcp"><a class="header" href="#why-choose-tcp">Why choose TCP?</a></h3>
<p>The TCP transport layer is ideal for scenarios where reliable, ordered, and error-checked
delivery of a stream of data is crucial. It ensures that data is delivered in the order it
was sent and retransmits lost packets. This makes TCP suitable for applications where data
integrity and accuracy are more important than speed.</p>
<p>TCP is especially useful if messages are going to be sent over public internet links, where
the quality of the connection cannot be guaranteed and a significant portion of packets may
be lost or corrupted.</p>
<h3 id="how-to-use-tcp"><a class="header" href="#how-to-use-tcp">How to use TCP</a></h3>
<p>In MSG, here is how you can setup any socket type with the TCP transport:</p>
<pre><pre class="playground"><code class="language-rust">use msg::{RepSocket, ReqSocket, tcp::Tcp};

#[tokio::main]
async fn main() {
    // Initialize the reply socket (server side) with default TCP
    let mut rep = RepSocket::new(Tcp::default());
    // Bind the socket to the address. This will start listening for incoming connections.
    // This method does DNS resolution internally, so you can use hostnames here.
    rep.bind("0.0.0.0:4444").await.unwrap();

    // Initialize the request socket (client side) with default TCP
    let mut req = ReqSocket::new(Tcp::default());
    // Connect the socket to the address. This will initiate a connection to the server.
    // This method does DNS resolution internally, so you can use hostnames here.
    req.connect("0.0.0.0:4444").await.unwrap();

    // ...
}</code></pre></pre>
<h2 id="quic"><a class="header" href="#quic">QUIC</a></h2>
<h3 id="why-choose-quic"><a class="header" href="#why-choose-quic">Why choose QUIC?</a></h3>
<p>QUIC is a new transport layer protocol that is built on top of UDP. It is designed to provide the same
reliability &amp; security guarantees as TCP + TLS, while solving some of the issues that it has, like</p>
<ul>
<li><strong>Head-of-line blocking</strong>: If a packet is lost, all subsequent packets are held up until the lost packet
is retransmitted. This can be a problem especially when multiplexing multiple streams over a single
connection because it can cause a single slow stream to block all other streams.</li>
<li><strong>Slow connection setup</strong>: TCP + TLS requires 2-3 round trips to establish a connection, which can be
slow on high latency networks.</li>
<li><strong>No support for multiplexing</strong>: TCP does not support multiplexing multiple streams over a single connection.
This means that if you want to send multiple streams of data over a single connection, you have to
implement your own multiplexing layer on top of TCP, which can run into issues like head-of-line
blocking that we've seen above.</li>
</ul>
<h3 id="quic-in-msg"><a class="header" href="#quic-in-msg">QUIC in MSG</a></h3>
<p>The MSG QUIC implementation is based on <a href="https://github.com/quinn-rs/quinn">quinn</a>. It relies on self-signed
certificates and does not verify server certificates. Also, due to how our <code>Transport</code> abstraction works, we
don't support QUIC connections with multiple streams. This means that the <code>Quic</code> transport implementation will
do all its work over a single, bi-directional stream for now.</p>
<h3 id="how-to-use-quic"><a class="header" href="#how-to-use-quic">How to use QUIC</a></h3>
<p>In MSG, here is how you can setup any socket type with the QUIC transport:</p>
<pre><pre class="playground"><code class="language-rust">use msg::{RepSocket, ReqSocket, Quic};

#[tokio::main]
async fn main() {
    // Initialize the reply socket (server side) with default QUIC
    let mut rep = RepSocket::new(Quic::default());
    // Bind the socket to the address. This will start listening for incoming connections.
    // This method does DNS resolution internally, so you can use hostnames here.
    rep.bind("0.0.0.0:4444").await.unwrap();

    // Initialize the request socket (client side) with default QUIC
    let mut req = ReqSocket::new(Quic::default());
    // Connect the socket to the address. This will initiate a connection to the server.
    // This method does DNS resolution internally, so you can use hostnames here.
    req.connect("0.0.0.0:4444").await.unwrap();

    // ...
}</code></pre></pre>
<h2 id="ipc"><a class="header" href="#ipc">IPC</a></h2>
<p>More precisely, MSG-RS supports <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix Domain Sockets (UDS)</a> for IPC.</p>
<h3 id="why-choose-ipc"><a class="header" href="#why-choose-ipc">Why choose IPC?</a></h3>
<p>IPC is a transport layer that allows for communication between processes on the same machine.
The main difference between IPC and other transport layers is that IPC sockets use the filesystem
as the address namespace.</p>
<p>IPC is useful when you want to avoid the overhead of network sockets and want to have a low-latency
communication link between processes on the same machine, all while being able to use the same API
as the other transport layers that MSG-RS supports.</p>
<p>Due to its simplicity, IPC is typically faster than TCP and QUIC, but the exact performance improvements
also depend on the throughput of the underlying UDS implementation. We only recommend using IPC when you
know that the performance benefits outweigh the overhead of using a network socket.</p>
<h3 id="how-to-use-ipc"><a class="header" href="#how-to-use-ipc">How to use IPC</a></h3>
<p>In MSG, here is how you can setup any socket type with the IPC transport:</p>
<pre><pre class="playground"><code class="language-rust">use msg::{RepSocket, ReqSocket, Ipc};

#[tokio::main]
async fn main() {
    // Initialize the reply socket (server side) with default IPC
    let mut rep = RepSocket::new(Ipc::default());
    // Bind the socket to the address. This will start listening for incoming connections.
    // You can use any path that is valid for a Unix Domain Socket.
    rep.bind("/tmp/msg.sock").await.unwrap();

    // Initialize the request socket (client side) with default IPC
    let mut req = ReqSocket::new(Ipc::default());
    // Connect the socket to the address. This will initiate a connection to the server.
    req.connect("/tmp/msg.sock").await.unwrap();

    // ...
}</code></pre></pre>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Authentication is the process of verifying the identity of a user or process
before allowing access to resources.</p>
<p>In MSG, authentication is handled by users of the library through the
<code>Authenticator</code> trait. This trait is implemented by the user and passed to the
socket type when it is created.</p>
<p>Here is how the <code>Authenticator</code> trait is defined:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// msg-socket/src/lib.rs
pub trait Authenticator: Send + Sync + Unpin + 'static {
    fn authenticate(&amp;self, id: &amp;Bytes) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>authenticate</code> method is called by the library whenever a new connection
is established. The <code>id</code> parameter is the identity of the connecting peer.</p>
<p><strong>Note: the Authenticator is used by the server-side socket only!</strong></p>
<p>Here is an example of how you can add an authenticator to a
client-server application:</p>
<pre><pre class="playground"><code class="language-rust">use msg::{
    tcp::{self, tcp::Tcp},
    Authenticator, ReqSocket, RepSocket,
};

// Define some custom authentication logic
#[derive(Default)]
struct Auth;

impl Authenticator for Auth {
    fn authenticate(&amp;self, id: &amp;Bytes) -&gt; bool {
        println!("Auth request from: {:?}", id);
        // Custom authentication logic goes here
        // ...
        true
    }
}

#[tokio::main]
async fn main() {
    // Initialize the reply socket (server side) with a transport
    // and an authenticator that we just implemented:
    let mut rep = RepSocket::new(Tcp::default()).with_auth(Auth);
    rep.bind("0.0.0.0:4444").await.unwrap();

    // Initialize the request socket (client side) with a transport
    // and an identifier. This will implicitly turn on client authentication.
    // The identifier will be sent to the server when the connection is established.
    let mut req = ReqSocket::with_options(
        Tcp::default(),
        ReqOptions::default().auth_token(Bytes::from("client1")),
    );

    ...
}</code></pre></pre>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-compression"><a class="header" href="#message-compression">Message compression</a></h1>
<p>Sometimes, you may want to compress messages before sending them over the network.
MSG-RS supports message compression out of the box, and it is very easy to use.</p>
<p>Compression is most useful in scenarios where you are sending large messages over the network.
It can also help reduce the amount of bandwidth used by your application.</p>
<p>In MSG, compression is handled by the socket type:</p>
<ul>
<li><a href="usage/compression.html#requestresponse">Request/Response</a></li>
<li><a href="usage/compression.html#publishsubscribe">Publish/Subscribe</a></li>
</ul>
<hr />
<h2 id="requestresponse"><a class="header" href="#requestresponse">Request/Response</a></h2>
<p>You can also find a complete example in <a href="https://github.com/chainboudn/msg-rs/tree/main/msg/examples">msg/examples/reqrep_compression.rs</a>.</p>
<pre><pre class="playground"><code class="language-rust">use msg::{compression::GzipCompressor, ReqSocket, RepSocket, tcp::Tcp};

#[tokio::main]
async fn main() {
    // Initialize the reply socket (server side) with a transport
    let mut rep = RepSocket::new(Tcp::default())
            // Enable Gzip compression (compression level 6).
            .with_compressor(GzipCompressor::new(6));

    rep.bind("0.0.0.0:4444").await.unwrap();

    // Initialize the request socket (client side) with a transport
    let mut req = ReqSocket::new(Tcp::default())
            // Enable Gzip compression (compression level 6).
            // The request and response sockets *don't have to*
            // use the same compression algorithm or level.
            .with_compressor(GzipCompressor::new(6));

    req.connect("0.0.0.0:4444").await.unwrap();

    // ...
}</code></pre></pre>
<h2 id="publishsubscribe-1"><a class="header" href="#publishsubscribe-1">Publish/Subscribe</a></h2>
<p>You can also find a complete example in <a href="https://github.com/chainboudn/msg-rs/tree/main/msg/examples">msg/examples/pubsub_compression.rs</a>.</p>
<pre><pre class="playground"><code class="language-rust">use msg::{compression::GzipCompressor, PubSocket, SubSocket, tcp::Tcp};

#[tokio::main]
async fn main() {
    // Configure the publisher socket with options
    let mut pub_socket = PubSocket::new(Tcp::new())
        // Enable Gzip compression (compression level 6)
        .with_compressor(GzipCompressor::new(6));

    // Configure the subscribers with options
    let mut sub_socket = SubSocket::new(Tcp::default());

    // ...
}</code></pre></pre>
<p>By looking at this example, you might be wondering: "how does the subscriber know that the
publisher is compressing messages, if the subscriber is not configured with Gzip compression?"</p>
<p>The answer is that in MSG, compression is defined by the publisher for each message that is sent.
In practice, each message contains info in its <code>Header</code> that tells the subscriber whether the message
payload is compressed - and if so, which compression algorithm was used. The subscriber then uses this
info to decompress the message payload before making it available to the user.</p>
<p>All of this is done automatically by MSG and it works out of the box
with the default compression methods:</p>
<ul>
<li>Gzip</li>
<li>Zstd</li>
<li>Snappy</li>
<li>LZ4</li>
</ul>
<p>If you wish to use a custom compression algorithm, this is not exposed with a public API yet.
If you need this, please <a href="https://github.com/chainbound/msg-rs/issues/new">open an issue</a> on Github and we will prioritize it!</p>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="encryption"><a class="header" href="#encryption">Encryption</a></h1>
<p>Encryption over messages is not yet supported in MSG-RS unless you're using a transport layer that supports it (like QUIC).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>MSG-RS uses the <a href="https://docs.rs/tracing/latest/tracing/">tracing</a> ecosystem crate for logging.</p>
<p>The tracing targets are configured using the <a href="https://docs.rs/tracing-subscriber/latest/tracing_subscriber/">tracing-subscriber</a> crate.
They are named after the crates that they are used in, and can be configured using the <code>RUST_LOG</code> environment variable.</p>
<p>For example, to enable logging for the <code>msg_socket</code> crate in your program, simply set:</p>
<pre><code class="language-bash">RUST_LOG=msg_socket=debug cargo run
</code></pre>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>MSG-RS doesn't currently expose any <a href="https://docs.rs/metrics/latest/metrics/">metrics</a> by default.</p>
<p>If you are interested in this feature, please let us know by <a href="https://github.com/chainbound/msg-rs/issues/new">opening an issue</a>.</p>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="how-do-i-pronounce-msg-rs"><a class="header" href="#how-do-i-pronounce-msg-rs">How do I pronounce MSG-RS?</a></h2>
<p>You can either pronounce it as "message", or as "em-es-gee". We prefer the latter.</p>
<h2 id="is-msg-rs-production-ready"><a class="header" href="#is-msg-rs-production-ready">Is MSG-RS production ready?</a></h2>
<p>MSG-RS is currently in ALPHA, and is not yet recommended for use in production.</p>
<p>We plan to release MSG-RS to <a href="https://crates.io/">Crates.io</a> once it reaches a beta stage.
Until then, we recommend using the git dependency as shown in the <a href="usage/./getting-started.html">Getting started</a> section.</p>
<!-- External -->
<!-- MSG links -->
<!-- Chainbound links -->
<h2 id="what-is-the-minimum-supported-rust-version-msrv"><a class="header" href="#what-is-the-minimum-supported-rust-version-msrv">What is the minimum supported Rust version (MSRV)?</a></h2>
<p>MSG-RS currently supports Rust 1.75 or later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution guidelines</a></h1>
<p>Thanks for your interest in contributing to making MSG better!</p>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to contribute</a></h2>
<h3 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h3>
<p>To get started with MSG, you will need the Rust toolchain installed on your machine.
You can find the installation instructions <a href="https://www.rust-lang.org/tools/install">here</a>.</p>
<p>Once you have the necessary tools installed, you can clone the repository and run the tests:</p>
<pre><code class="language-shell">git clone git@github.com:chainbound/msg-rs.git
cd msg-rs

cargo test --all
</code></pre>
<h3 id="development-workflow"><a class="header" href="#development-workflow">Development workflow</a></h3>
<p>We use Github for all our development workflow. If you are not familiar with Github, you can find
a great guide <a href="https://guides.github.com/activities/hello-world/">here</a>.</p>
<p>We use Github issues to track all our work. If you want to contribute, you can find a list of
open issues <a href="https://github.com/chainbound/msg-rs/issues">here</a>. If you want to work on an issue,
please leave a comment on the specific issue so that we it can be assigned to you.</p>
<p>When testing your changes, please use the following commands and make sure that they all pass:</p>
<pre><code>cargo check --all
cargo test --all
cargo +nightly fmt -- --check
cargo +nightly clippy --all --all-features -- -D warnings
</code></pre>
<p>Once you are done with your changes, you can open a pull request. We will review your changes
and provide feedback. Once the changes are approved, your pull request will be merged.</p>
<h3 id="asking-for-help"><a class="header" href="#asking-for-help">Asking for help</a></h3>
<p>If you have any questions, you can open a <a href="https://github.com/chainbound/msg-rs/issues/new">new issue</a>
or join our <a href="https://discord.gg/nhWcSWYpm9">Discord server</a>.</p>
<h3 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of conduct</a></h3>
<p>MSG adheres to the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>.
This document describes the minimum behavior expected from all contributors.</p>
<h3 id="license"><a class="header" href="#license">License</a></h3>
<p>By contributing to MSG, you agree that your contributions will be licensed under its
<a href="https://github.com/chainbound/msg-rs/blob/main/LICENSE">MIT license</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
